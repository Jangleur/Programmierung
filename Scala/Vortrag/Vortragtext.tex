\section[Section]{Vortragtext}
	\begin{frame}
	Folie 0: Der Vortrag soll nur einen sehr groben Einstieg in die Idee der Funktionalen Programmierung liefern. Also warum man den Funktionalen Ansatz verwenden sollte. Das ganze bezieht sich dabei auf ein Buch vom Manning Verlag und dabei eigentlich auch nur auf das erste Kapitel. Ich bin kein Scala Experte, sondern habe mich bis jetzt nur ein paar Wochen ein wenig damit auseinandergesetzt. Wenn ihr also Fragen habt, könnt ihr die gerne Stellen, aber ich kann leider nicht garantieren das ich eine Antwort weiß. 
	
	Folie 1: Was ist ein Seiteneffekt? Eine Funktion hat einen Seiteneffekt, wenn es etwas anderes macht als einfach ein Ergebnis zurück zu liefern. Das scheint natürlich erst ein Mal eine große Einschränkung zu sein. Wenn ich keine Variablen neu belegen kann, wie schreibe ich
	dann Schleifen. Ich denke die meisten hier können sich in dem Fall die
	Antwort denken. Eben durch Rekursion. Es gibt also durchaus 	     Möglichkeiten Programme zu schreiben, in denen Schleifen normalerweise benötigt werden, ohne aber Schleifen zu verwenden. Das gilt auch für die anderen hier aufgezählten Beispiele. Da fragt man sich aber auch dann was das ganze denn überhaupt soll, wenn man es doch auch einfach ohne diesen Funktionalen Ansatz machen kann. Also was bringt einem solch eine Einschränkung? Die Antwort ist Modularität d.h. .... Dadurch sind reine Funktionen vor allem leicht testbar und wiederverwertbar (wie gemeint? man kann doch auch normale methoden mehr als ein Mal verwenden). Was das bedeutet, werde ich noch an einem Beispiel aus dem Buch zeigen. An dem Beispiel kann man auch erkennen, wie man aus einem Programm mit Seiteneffekten umschreiben kann in eines ohne Seiteneffekte. Zuvor werde ich aber erst ein paar Begriffe erklären.
	
	Folie 2: Das bedeutet natürlich nicht das nur genau einen Wert a geben muss, welcher auf b abgebildet wird. Also die Funktion muss nicht injektiv sein. Wichtig ist bloß, eine reine Funktion macht nichts anderes als den Wert a auf den Wert b abzubilden. Hier sind zwei Beispiele für Funktionen. Gut. Nun wissen wir was überhaupt eine reine Funktion ist. Um nun zu erkennen wann ein Programm Seiteneffekte hat und wie man diese beheben kann, benötigt man allerdings noch ein paar weitere Defintionen. Zunächst ein mal die eines Ausdrucks. Alternativ:
	Dieses Konzept bzw. Idee einer reinen Funktion lässt sich noch etwas allgemeiner für Ausdrücke formulieren. 
	
	Folie 3: .Ja, warum muss man wissen was ein Ausdruck ist? Man benötigt dies um zu verstehen was referenzielle transparenz bedeutet. Das ist ein weiterer Begriff, zu dem ich nun komme. Alternativ: 2+3 ist ein Ausdruck welcher die Funktion der Addition auf 2 und 3 anwendet. Das Ergebnis ist 5 und man kann den Ausdruck auch einfach durch 5 ersetzen. Das würde nichts an der Bedeutung des Programms ändern. Man nennt diese Eigenschaft auch referenziell Transparent d.h. man kann den Ausdruck durch sein Ergebnis ersetzen und ändert damit nicht die Bedeutung des Programms. 
	
	Folie 4: Ja. Hier haben wir damit dann auch noch mal eine präzisere 
	Eigenschaft, mit der man überprüfen kann ob eine Funktion wirklich rein ist. Also dieses "macht sonst nichts anderes" in der Definition einer reinen Funktion ist hier etwas präziser gefasst. Nun jetzt habe ich ein paar Begriffe erklärt und komme dann nun zum angekündigten Beispiel. Durch RT lässt sich das was eine Funktion tut, schon durch dessen Rückgabewert beschreiben. Man muss sich auch keine Gedanken um einen möglichen Zustand der Funktionen oder des Programms machen. Sondern es genügt lokal zu schließen d.h. um ein Programm zu verstehen, muss man nur auf die Definitionen der Funktionen achten und diese im Programm anwenden.  
	
	Folie 5: Wir haben hier eine Klasse Cafe und diese hat eine Methode um einen Kaffee zu kaufen. In Scala stehen die Typen immer vor dem Variablen Namen. So das man das ganze so lesen kann "cc ist vom Typ CreditCard". val definiert eine unveränderbare Variable. Semikolons werden in Scala nicht benötigt und der letzte Ausdruck am Ende der Methode ist automatisch das was zurück gegeben wird von der Methode. Wir brauchen also kein return. Wie der Titel der Folie schon andeutet ist dies ein Progamm mit Seiteneffekten. Genauer gesagt gibt es genau da einen Seiteneffekt. Man hat hier eine Interaktion mit der Außenwelt weil man z.B. über einen Webservice die Kreditkartenfirma aufrufen muss. Man weiß vielleicht gar nicht wie diese Methode charge arbeitet. Könnte ja möglicherweise so ablaufen. Wenn man sich die unsere Methode buyCoffee aber anschaut so sieht man diese gibt bloß einen Kaffee wieder und wenn es sich um eine hierbei um eine reine Funktion handeln würde, würde die Methode bzw. Funktion auch nichts anderes tun. Aufgrund dieses  Seiteneffektes ist die Methode schwierig zu testen. Denn wenn bei jedem Test die Kredikartenfirma eventuell benachrichtigt werden muss, ist dies natürlich nicht so toll. Ein weiteres Problem ist hierbei die wieder verwendbarkeit. Wenn man z.B. mehr als ein Mal einen Kaffee bestellt,
so muss man die Methode öfters aufrufen und jedes Mal einzeln wird das Kreditkarten Unternehmen benachrichtigt. Oder auch wenn man etwas anderes kauft, kann man dies nicht zusammen mit dem Kaffee abbrechnen lassen. 

Folie 6: Wie sieht nun eine Funktionale Lösung aus?
Folie 7: Nun man gibt den Charge als zusätzlichen Rückgabewert wieder.
Hier gibt es nun eine Trennung zwischen dem erzeugen eines Charges und dem was man damit letzendlich macht. Ich hatte ja gesagt, dass man möglicherweise extra einen Webservice aufrufen muss und so weiter. Das ist hier nun nicht mehr der Fall. Der Charge wird zurück gegeben und das wars dann. Die anderen Dinge werden an anderer Stelle getan. Man sagt dazu auch, das man Programme versucht so zu schreiben, dass sie einen reinen Kern haben und eine dünne Schicht nach außen. 

Zur Modularität: Modulare Programme bestehen aus Komponenten, welche man unabhängig vom Ganzen verwenden und verstehen kann. Dabei hängt die Bedeutung des großen ganzen nur von der Bedeutung der einzelnen Komponenten ab und von den Reglen wie diese Komponenten sich zusammensetzen lassen. Eine reine Funktion ist modular, weil es die Logik der Berechnung trennt von "was macht man mit dem Resultat" und 
"wie erhält man den input". Input erhält man über die Argumente und der Output wird einfach wieder gegeben. Dadurch lassen sich Funktionen leicht verwenden ohne das man sich über seiteneffekte gedanken machen muss. 
	
	\end{frame}