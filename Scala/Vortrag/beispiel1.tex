	\section[Section]{Beispiele Seiteneffekt}
		\begin{frame}[fragile]
		\frametitle{Beispiel mit Seiteneffekt}
		\begin{lstlisting}[style=myScalastyle]
class Cafe {
	def buyCoffee(cc: CreditCard): Coffee = {
		val cup = new Coffee()
		cc.charge(cup.price)
		cup
	}
}
\end{lstlisting}
\begin{itemize}
				\item[•] Seiteneffekt: Returntype von cc.charge(cup.price) nicht sichtbar
				\item[•] Überprüfung referenzielle Transparenz: \\ p(buyCoffee(aCreditCard)) $\neq$ p(new Coffee())
				\end{itemize}
		 %Das Ergebnis von buyCoffee(aCreditCard) ist
		%nur cup, was äquivalent zu new Coffee() ist. Wenn buyCoffee eine reine 				Funktion wäre, so müsste für jedes Programm p, sich 								p(buyCoffee(aCreditCard)) und p(new Coffee()) gleich verhalten.

\end{frame}
		
			